# Variable

## 1. 变量声明

Rust 中的变量声明使用 `let` 关键字，变量的类型可以通过类型推导自动推断，也可以通过 `:` 显式指定。

通常情况下 `let` 关键字声明的变量是**不可变**的，如果需要**可变**变量，可以使用 `mut` 关键字。

`const` 声明常量，常量的值在程序运行期间不会改变，并且常量必须**显式指定类型**。

```rust
let a = 1;              // 类型推导 默认i32
let b: i32 = 2;         // 显式指定类型
let mut c = 3;          // 可变变量
const MAX: i32 = 100;   // 常量
```

## 2. 变量的作用域与遮蔽

变量的作用域是从声明开始到当前代码块结束。离开作用域后，变量会被自动释放。

Rust 允许你使用相同的变量名重新声明一个变量，这称为 **变量遮蔽** 。
新变量会覆盖旧变量，但它们可以是不同的类型

```rust
fn main() {
    let outer = 10;                     // 外层变量
    let outer = outer + 1;              // 覆盖之前的 outer

    {
        let inner = 5;                  // 内层变量
        let outer = outer * 2;          // 作用域内再次遮蔽
        println!("inner = {}", inner);
    }                                   // inner 离开作用域，被释放

    // println!("inner = {}", inner);   // 这行会报错，因为 inner 已经不存在
    println!("outer = {}", outer);
}
```

## 3. 变量的解构与赋值

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

## 4. 变量的解引用与绑定

Rust 中的解引用操作使用 `*` 符号，可以将引用类型解引用为值类型。

```rust
fn main() {
    let a = 1;
    let b = &a;         // b 是一个指向 a 的引用
    let c = *b;         // c 是 b 的解引用，值为 1

    assert_eq!(a, c);
}
```
