# owner

## 1. 所有权的规则

Rust 的所有权系统基于以下三条核心规则：

- 每一个值都有一个被称为其所有者的变量。
- 同一时间，只能有一个所有者。
- 当所有者离开作用域时，这个值将被释放。

## 2. 所有权的转移(Move)

Rust 中的所有权是通过 **所有权转移** 来实现的，当一个值的所有权被转移给另一个变量时，原来的变量将无法再使用这个值。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有权转移
    // println!("{}", s1); // 这行会报错，因为 s1 的所有权已经转移给 s2
    println!("{}", s2);
}
```

## 3. 所有权的克隆(Clone)

如果需要复制一个堆上的数据，可以使用 `clone` 方法，这样就会复制一份新的数据，而不是转移所有权。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 克隆
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

> [!note]
> 克隆是一个深拷贝，它会为所有数据分配新的内存。如果你不需要完全的复制，最好避免不必要的克隆。

## 4. 借用(Borrow)

Rust 中的借用是通过引用来实现的，引用允许你使用值而不获取其所有权。

借用可以分为两种：

- 不可变借用：`&T`
- 可变借用：`&mut T`

不可变借用允许你读取值，但不能修改值。

```rust
fn main() {
    let s1 = String::from("Hello");

    let s2 = &s1; // 不可变借用
    println!("{}", s2); // 可以通过 s2 访问 s1 的值
    // s1 仍然有效，依然可以使用
    println!("{}", s1);
}
```

可变借用意味着你可以修改值，但借用期间无法拥有其他的不可变借用。

```rust
fn main() {
    let mut s1 = String::from("Hello");

    let s2 = &mut s1; // 可变借用
    s2.push_str(", world!"); // 修改借用的值
    println!("{}", s2); // 输出修改后的字符串

    // println!("{}", s1); // 错误，s1 在借用期间不可用
}
```

> [!caution]
> 在同一时间内，你不能同时拥有值的多个 **不可变借用** 或者 **可变借用**。

## 5. 切片(Slice)

切片是对一个数组或者字符串的引用，它不拥有值的所有权，也不会发生所有权转移。

```rust
fn main() {
    let s = String::from("Hello, Rust!");
    let slice = &s[0..5]; // 切片借用
    println!("切片: {}", slice); // "Hello"
    println!("原始字符串: {}", s); // 原字符串依然有效
}
```
