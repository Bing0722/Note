## Effective C++

### 绪论0

#### explicit

当构造函数声明为`explicit`，这可以阻止它们被用来执行隐式类型转换，但它仍可以被进行显示类型转换。(尽量使用)

#### 命名习惯

做到见名知意

### 条款01:将c++视为一个语言联邦

为了理解c++你必须认识其主要的次语言：

- **C++的C语言部分**：C++仍然是基于C的，块、语句、预处理器、内置数据类型、数组、指针等都来自C。
- **C++的面向对象部分**：C++的这一部分就是`C with Classes`的全部内容：类、封装、继承、多态、虚函数等。这是C++中面向对象设计的经典规则最直接适用的部分。
- **C++的模板部分**：这个是C++的泛型编程部分。事实上模板是如此强大。它们产生了一种全新的编程范式，模板元编程（**temple metadata programming， TMP**）。
- **C++的STL部分**：STL是一个模板库，但是它是一个非常特殊的模板库。它通过一些约定，很好地将容器、迭代器、算法和函数对象融合在一起。使用STL时，你需要确保遵循它的约定。

### 条款2:尽量以`const`,`enum`,`inline`替换`#define`

1. 将宏定义常量`#define PI 3.14`替换成`const`类型的常量
   - 使用`const double Pi = 3.14`来替换宏定义
   - 使用`const std::string name("Tom")`来替换宏定义的字符常量

2. 如果把常量的作用域限制为类，就必须把它设为成员；要确保最多有一个常量的副本，就必须把他设置为静态成员。（**注意**：类内的静态成员需要定义才能使用）

   > 通常，C++要求为所使用的任何东西提供定义，但类专用的静态整数类型(例如`int`、`char`、`bool`)常量是个例外，只要不获取它们的地址，就可以在不提供定义的情况下声明并使用它们。

3. 另一种方式就是枚举，枚举类型的值可以在需要`int`的地方使用。

4. 通过使用内联函数模板，可以获得宏函数的所有效率，以及普通函数的可预测行为和类型安全。

**总结**：

- 对于简单常量，首选`const`对象或枚举，而不是`#define`
- 对于类似函数的宏，优先选择内联函数。

### 条款3：尽可能使用`const`

1. `const`关键字在用于指针的时候，用途非常广泛。
   - `const char *p`：此处的`const`修饰的是指针指向的变量**不可修改**，但是指针的指向**可修改**。
   - `char * const p`：此处的`const`修饰的是指针的地址**不可修改**，但是指针指向的变量**可修改**。
   - `const char* const p`：这样的话指针的指向和指针指向的变量**都不可修改**。

2. 在成员函数上使用`const`:

   - 使类的接口意图更明确。知道那些函数可以修改一个对象，哪些不可以，这很重要。

   - 使得使用`const`对象成为可能。

     > C++的一个重要特性：仅在常量上不同的成员函数可以被重载。

3. 成员函数`const`是什么意思？有两种流行的概念：位常量(也称为物理常量)和逻辑常量。
4. 避免`const`重载的代码重复：
   - 让一个版本调用另一个版本，先写`const`版本，然后脱离`const`限制。

### 确保对象在使用之前被初始化

