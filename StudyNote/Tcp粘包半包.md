## 粘包和半包

在TCP连接中，粘包和半包问题是由于TCP协议的流式传输机制引发的，主要发生在发送和接收数据时。

## 粘包

**粘包**是指一次发送的多条消息粘连在一起，被接收方当作一条数据来处理。TCP 是面向字节流的协议，它不会关心应用层数据的边界，只会根据自身的优化策略进行数据发送。

**粘包可能发生的情况**:
- 发送方多次调用 `send()` 发送了多个数据包，但由于 TCP 的优化机制，可能会将多个包合并成一个包发送给接收方。
- 接收方一次 `recv()` 调用会从接收缓冲区读取多个粘连在一起的数据，导致无法区分哪部分属于哪条消息。


## 半包

**半包**是指一次发送的消息被拆分成了多个数据包发送，接收方一次 `recv()` 只读取到一部分数据，必须多次读取才能获得完整的数据。

**半包可能发生的情况**:
- 发送方发送的数据量超过了TCP的最大传输单元（MTU），TCP会将数据拆分成多个数据包发送。
- 接收方调用 `recv()` 时只读取到一部分数据，剩余的数据需要再次调用 `recv()` 才能接收到。

## 解决方案

1.  **定长消息法**
每条消息的长度是固定的，例如每条消息都是 100 字节，不足时补 0。这种方式简单明了，但在实际应用中并不灵活，容易浪费带宽。
```c
char buffer[100];
recv(socket_fd, buffer, 100, 0);  // 每次都接收 100 字节
```

2. **消息加分隔符法**
可以在每条消息的末尾加上一个特殊的分隔符，例如 `\n` 或者其他自定义的符号。接收方在收到数据时，根据分隔符来切分消息。
```c
// 发送时在消息末尾加分隔符
send(socket_fd, "Message1\n", strlen("Message1\n"), 0);
send(socket_fd, "Message2\n", strlen("Message2\n"), 0);

// 接收方通过判断分隔符来拆解消息
char buffer[1024];
int len = recv(socket_fd, buffer, sizeof(buffer), 0);
std::string data(buffer, len);
std::vector<std::string> messages = split(data, '\n');
```

3. **消息头加消息体长度法**
在消息的头部加上一个固定长度的字段，用来存储消息体的长度。接收方先读取消息头的长度字段，根据长度字段再读取完整的消息体。
**发送时**:
```c
// 先发送消息体长度，再发送消息
uint32_t msgLen = htonl(strlen("Message1"));
send(socket_fd, &msgLen, sizeof(msgLen), 0);
send(socket_fd, "Message1", strlen("Message1"), 0);
```
**接收时**:
```c
// 先接收消息长度
uint32_t msgLen;
recv(socket_fd, &msgLen, sizeof(msgLen), 0);
msgLen = ntohl(msgLen);

// 根据长度接收完整的消息体
char *msgBody = new char[msgLen];
recv(socket_fd, msgBody, msgLen, 0);
```

4. 应用层协议设计
在更复杂的场景中，你可以设计自己的应用层协议。每条消息可以有消息类型、消息长度、校验码等多个字段，接收方根据协议格式来解析消息。

## 总结
- **粘包**：多条消息在 TCP 传输过程中被合并，导致接收方无法区分消息边界。
- **半包**：一条消息在 TCP 传输过程中被拆分，导致接收方需要多次接收才能获得完整的消息。
- 解决这类问题的核心是设计一个**消息分隔机制**，常用的方法包括定长消息、分隔符、消息长度前缀等。